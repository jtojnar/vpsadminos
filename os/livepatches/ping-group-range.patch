diff --git a/kernel/user_namespace.c b/kernel/user_namespace.c
index 708bf385c166..4841413ef748 100644
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@ -325,6 +325,28 @@ static u32 map_id_down(struct uid_gid_map *map, u32 id)
 	return map_id_range_down(map, id, 1);
 }
 
+extern u32 get_map_highest_id(struct uid_gid_map *map);
+u32 get_map_highest_id(struct uid_gid_map *map)
+{
+	unsigned idx;
+	u32 high, highest = 0;
+	struct uid_gid_extent *walkmap, *extent;
+	smp_rmb();
+
+	if (map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)
+		walkmap = map->extent;
+	else
+		walkmap = map->forward;
+
+	for (idx = 0; idx < map->nr_extents; idx++) {
+		extent = &walkmap[idx];
+		high = extent->first + extent->count - 1;
+		if (high > highest)
+			highest = high;
+	}
+	return highest;
+}
+
 /**
  * map_id_up_base - Find idmap via binary search in static extent array.
  * Can only be called if number of mappings is equal or less than
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index 08829809e88b..287e545a8051 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -165,6 +165,9 @@ static void set_ping_group_range(struct ctl_table *table, kgid_t low, kgid_t hig
 	write_sequnlock(&net->ipv4.ping_group_range.lock);
 }
 
+extern u32 get_map_highest_id(struct uid_gid_map *map);
+
+
 /* Validate changes from /proc interface. */
 static int ipv4_ping_group_range(struct ctl_table *table, int write,
 				 void *buffer, size_t *lenp, loff_t *ppos)
@@ -189,6 +192,12 @@ static int ipv4_ping_group_range(struct ctl_table *table, int write,
 	if (write && ret == 0) {
 		low = make_kgid(user_ns, urange[0]);
 		high = make_kgid(user_ns, urange[1]);
+		if (user_ns != &init_user_ns) {
+			if (urange[1] >= (((gid_t)~0U) >> 1)) {
+				u32 ns_overflowgid = get_map_highest_id(&user_ns->gid_map);
+				high = make_kgid(user_ns, ns_overflowgid);
+			}
+		}
 		if (!gid_valid(low) || !gid_valid(high))
 			return -EINVAL;
 		if (urange[1] < urange[0] || gid_lt(high, low)) {
